
//   Important note about DLL memory management when your DLL uses the
//   static version of the RunTime Library:
//
//   If your DLL exports any functions that pass String objects (or structs/
//   classes containing nested Strings) as parameter or function results,
//   you will need to add the library MEMMGR.LIB to both the DLL project and
//   any other projects that use the DLL.  You will also need to use MEMMGR.LIB
//   if any other projects which use the DLL will be performing new or delete
//   operations on any non-TObject-derived classes which are exported from the
//   DLL. Adding MEMMGR.LIB to your project will change the DLL and its calling
//   EXE's to use the BORLNDMM.DLL as their memory manager.  In these cases,
//   the file BORLNDMM.DLL should be deployed along with your DLL.
//
//   To avoid using BORLNDMM.DLL, pass string information using "char *" or
//   ShortString parameters.
//
//   If your DLL uses the dynamic version of the RTL, you do not need to
//   explicitly add MEMMGR.LIB as this will be done implicitly for you

#pragma hdrstop
#pragma argsused

#include <vcl.h>
#include <windows.h>
#include <fstream>
#include <Python.h>
#include <vector>

int WINAPI DllEntryPoint(HINSTANCE hinst, unsigned long reason, void* lpReserved)
{
	return 1;
}

#define FMI_COSIMULATION

// define class name and unique id
#define MODEL_IDENTIFIER PythonModel
#define MODEL_GUID "{8c4e810f-3df3-4a00-8276-176fa3c9f003}"
#define REAL 0
#define INTEGER 1
#define BOOL 2
#define STRING 3

// define model size
#define NUMBER_OF_REALS 3
#define NUMBER_OF_INTEGERS 0
#define NUMBER_OF_BOOLEANS 0
#define NUMBER_OF_STRINGS 0
#define NUMBER_OF_STATES 0
#define NUMBER_OF_EVENT_INDICATORS 0

// include fmu header files, typedefs and macros
#include "fmuTemplate.h"

// called by fmiInstantiateModel
// Set values for all variables that define a start value
// Settings used unless changed by fmiSetX before fmiInitialize
void setStartValues(ModelInstance* comp) {
//	r(0) = 2;
//	r(1) = 3;
//    r(2) = 6;
}


// Tuples:
PyObject* BuildTuple(fmiComponent c, ModelInstance* comp, unsigned type_)
{
	// We create a new Tuple
	unsigned int size = 0;
	if (type_ == REAL)
		size = comp->realValues.size();
	if (type_ == INTEGER)
		size = comp->intValues.size();
	if (type_ == BOOL)
		size = comp->boolValues.size();
	if (type_ == STRING)
		size = comp->strValues.size();

	PyObject* newTuple = PyTuple_New(size);
	if (newTuple == 0) {
			// Error
			comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Couldn't create a tuple!");
		return 0;
	}

	for (unsigned i = 0; i < size; i++) {
		PyObject* obj;
		if (type_ == REAL)
			obj = PyFloat_FromDouble(comp->realValues[i].value);
		if (type_ == INTEGER)
			obj = PyInt_FromLong(comp->intValues[i].value);
		if (type_ == BOOL)
			obj = PyBool_FromLong(comp->boolValues[i].value);
		if (type_ == STRING)
			obj = PyString_FromString(comp->strValues[i].value);

		if (obj == 0) {
			// clean up
			Py_DECREF(newTuple);
			comp->functions.logger(c, comp->instanceName, fmiOK, "log",
									 "Couldn't store a new value in the tuple!");
			return 0;
		}
		PyTuple_SetItem(newTuple, i, obj);
	}

	return newTuple;
}
//
//// Tuples: float
//PyObject* BuildTupleReal(std::vector<fmiReal> &listReal, std::fstream &out)
//{
//	// We create a new Tuple
//	PyObject* newTuple = PyTuple_New(listReal.size());
//	if (newTuple == 0) {
//			// Error
//			out << "Couldn't create a tuple!" << std::endl;
//		return 0;
//	}
//
//	for (unsigned i = 0; i < listReal.size(); i++) {
//		PyObject* obj = PyFloat_FromDouble(listReal[i]);
//		if (obj == 0) {
//			// clean up
//			Py_DECREF(newTuple);
//			out << "Couldn't store a new float in the tuple!" << std::endl;
//			return 0;
//		}
//		PyTuple_SetItem(newTuple, 0, obj);
//	}
//
//	return newTuple;
//}
//
//// Tuples: int
//PyObject* BuildTupleInteger(std::vector<fmiInteger> &listInt, std::fstream &out)
//{
//	// We create a new Tuple
//	PyObject* newTuple = PyTuple_New(listInt.size());
//	if (newTuple == 0) {
//			// Error
//			out << "Couldn't create a tuple!" << std::endl;
//		return 0;
//	}
//
//	for (unsigned i = 0; i < listInt.size(); i++) {
//		PyObject* obj = PyInt_FromLong(listInt[i]);
//		if (obj == 0) {
//			// clean up
//			Py_DECREF(newTuple);
//			out << "Couldn't store a new float in the tuple!" << std::endl;
//			return 0;
//		}
//		PyTuple_SetItem(newTuple, 0, obj);
//	}
//
//	return newTuple;
//}
//
//// Tuples: string
//PyObject* BuildTupleString(std::vector<fmiString> &listString, std::fstream &out)
//{
//	// We create a new Tuple
//	PyObject* newTuple = PyTuple_New(listString.size());
//	if (newTuple == 0) {
//			// Error
//			out << "Couldn't create a tuple!" << std::endl;
//		return 0;
//	}
//
//	for (unsigned i = 0; i < listString.size(); i++) {
//		PyObject* obj = PyString_FromString(listString[i]);
//		if (obj == 0) {
//			// clean up
//			Py_DECREF(newTuple);
//			out << "Couldn't store a new float in the tuple!" << std::endl;
//			return 0;
//		}
//		PyTuple_SetItem(newTuple, 0, obj);
//	}
//
//	return newTuple;
//}

void UpdateVariables(fmiComponent c, ModelInstance* comp, PyObject* myModule)
{
	//set real variables
	PyObject* myFunction = PyObject_GetAttrString(myModule,(char*)"SetReal");
	comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Creating tuple for real array...");
	PyObject *args = BuildTuple(c,comp,REAL);
	comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Calling python SetReal");
	PyObject_CallObject(myFunction, args);

	Py_DECREF(args);
	Py_DECREF(myFunction);

	//set int variables
	myFunction = PyObject_GetAttrString(myModule,(char*)"SetInteger");
	comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Creating tuple for integer array...");
	args = BuildTuple(c,comp,INTEGER);
	comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Calling python SetInteger");
	PyObject_CallObject(myFunction, args);

	Py_DECREF(args);
	Py_DECREF(myFunction);

	//set string variables
	myFunction = PyObject_GetAttrString(myModule,(char*)"SetBoolean");
	comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Creating tuple for boolean array...");
	args = BuildTuple(c,comp,BOOL);
	comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Calling python SetBoolean");
	PyObject_CallObject(myFunction, args);

	Py_DECREF(args);
	Py_DECREF(myFunction);

	//set string variables
	myFunction = PyObject_GetAttrString(myModule,(char*)"SetString");
	comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Creating tuple for string array...");
	args = BuildTuple(c,comp,STRING);
	comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Calling python SetString");
	PyObject_CallObject(myFunction, args);

	Py_DECREF(args);
	Py_DECREF(myFunction);
}

// called by fmiInitialize() after setting eventInfo to defaults
// Used to set the first time event, if any.
bool initialize(fmiComponent c, ModelInstance* comp, fmiEventInfo* eventInfo)
{
	try {
		//out << "Vai Inicializar o python " << std::endl;
		comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Initializing Python");
		Py_Initialize();

		comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Setting path ..\\..\\sources");
		PyObject* myPath = PySys_GetObject("path");
		PyObject* myPathString = PyString_FromString((char*)"..\\..\\sources");
		int res = PyList_Append(myPath, myPathString);
//		size = PyList_Size(myPath);
//		for (int i = 0; i < size; i++)
//			out << "Path atual " << PyString_AsString(PyList_GetItem(myPath,i)) << std::endl;

		PyObject* myModuleString = PyString_FromString((char*)"initialize");
		comp->functions.logger(c, comp->instanceName, fmiOK, "log",
										"Importing EventUpdate python module...");
		PyObject* myModule = PyImport_Import(myModuleString);

		//update real, int, bool and string values em python code
		UpdateVariables(c, comp, myModule);

		//run initialize main
		comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Getting python main() function...");
		PyObject *myFunction = PyObject_GetAttrString(myModule,(char*)"main");
		comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Calling function main()");
		PyObject_CallObject(myFunction, 0);
		// Clean up
		//Py_DECREF(result);
		Py_DECREF(myFunction);
		Py_DECREF(myModule);
		Py_DECREF(myModuleString);

		eventInfo->upcomingTimeEvent   = fmiTrue;
		eventInfo->nextEventTime       = 1 + comp->time;

	}catch(...)
	{
		comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Error in python interface initialization");
		return false;
	}
	return true;
}
//------------------------------------------------------------------------------

//
fmiReal getEventIndicator(ModelInstance* comp, int z)
{
	return 1;
}

// Used to set the next time event, if any.
void eventUpdate(fmiComponent c, ModelInstance* comp, fmiEventInfo* eventInfo)
{
//	std::fstream out;
//	out.open("F:\\2018\\FMU\\TestFMUPythonModel\\tempOut.txt",std::fstream::out);

//	PyObject *moduleMainString = PyString_FromString("__main__");
//	PyObject *moduleMain = PyImport_Import(moduleMainString);
//	out << "Vai rodar PyRun_SimpleString" << std::endl;
//	PyRun_SimpleString(
//		"def mult(a, b):                                 \n"\
//		"   return a * b                                \n"\
//	);
//	out << "Rodou PyRun_SimpleString" << std::endl;
//	PyObject *func = PyObject_GetAttrString(moduleMain, "mult");
//	PyObject *args = PyTuple_Pack(2, PyFloat_FromDouble(r(0)), PyFloat_FromDouble(r(1)));
//
//	PyObject *result = PyObject_CallObject(func, args);
	//out << "Vai rodar PyString_FromString" << std::endl;
	PyObject* myModuleString = PyString_FromString((char*)"eventUpdate");

//	out << "Vai rodar PyImport_Import" << std::endl;
	comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Importing EventUpdate python module...");
	PyObject* myModule = PyImport_Import(myModuleString);

	//out << "Vai UpdateVariables" << std::endl;
	comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Updating Input Variables...");
	//update real, int, bool and string values em python code
	UpdateVariables(c, comp, myModule);

	//out << "Vai rodar PyObject_GetAttrString" << std::endl;
	comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Getting python main() function...");
	PyObject* myFunction = PyObject_GetAttrString(myModule,(char*)"main");
	//out << "Vai rodar PyObject_CallObject" << std::endl;
	comp->functions.logger(c, comp->instanceName, fmiOK, "log", "Calling function main()");
	PyObject *result = PyObject_CallObject(myFunction, 0);
	//const char* s = PyString_AsString(result);
	//out << "Vai atribuir result = " << s << std::endl;
	//comp->r[2] = PyFloat_AsDouble(result);

	Py_DECREF(result);
	Py_DECREF(myFunction);
	Py_DECREF(myModule);
	Py_DECREF(myModuleString);

	eventInfo->upcomingTimeEvent   = fmiTrue;
	eventInfo->nextEventTime       = 1 + comp->time;
	eventInfo->iterationConverged  = fmiTrue;
	eventInfo->terminateSimulation = fmiFalse;
 }

//
void Finalize(ModelInstance* comp)
{
	Py_Finalize();
}
//------------------------------------------------------------------------------

// include code that implements the FMI based on the above definitions
#include "fmuTemplate.c"
